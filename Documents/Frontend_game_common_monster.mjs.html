<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Frontend/game/common/monster.mjs</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Frontend/game/common/monster.mjs</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* eslint-disable no-extra-parens,max-len,curly,no-console,complexity,prefer-template, no-warning-comments */
/** @module Monster */

export default class MonsterCommon {
  
  constructor(name_in, hp_in, damage_in, floor_in, id_in, type_in) {
    
    this.name = name_in;
    this.hp = hp_in;
    this.damage = damage_in;
    this.floor = floor_in;
    this.id = id_in;
    this.type = type_in;

    this.targetAquired = false; // "in pursuit" boolean
    this.x = 0; // (x,y) = upper left pixel coordinate
    this.y = 0;
    this.targetx = -1; // location where monster wants to move
    this.targety = -1;
    this.PCx = -1; // (-1,-1) if not seen yet or previously seen location explored
    this.PCy = -1;
    this.maneuver = false;

    this.placeInRandomRoom();

    this.figureOutWhereToGo();

    //this.die();
  }

  /** 
   * Returns true if monster can see given pixel coordinate.
   * @param x 
   * @param y 
   */
  canSee(x, y) {
    this.maneuver = false;
    let x1 = -1, x2 = -1, y1 = -1, y2 = -1;
    let cornerx = this.x, cornery = this.y; // upper left
    let clear = true;
    let totalCorners = 0;
    for(let i = 0; i &lt; 4; i++) {
      if(i === 1) {
        cornerx += MonsterCommon.SPRITE_SIZE; // upper right
      } else if(i === 2) {
        cornery += MonsterCommon.SPRITE_SIZE; // lower right
      } else if(i === 3) {
        cornerx -= MonsterCommon.SPRITE_SIZE; // lower left
      }
      if(x &lt; cornerx) {
        x1 = x;
        x2 = cornerx;
      } else {
        x1 = cornerx;
        x2 = x;
      }
      if(y &lt; cornery) {
        y1 = y;
        y2 = cornery;
      } else {
        y1 = cornery;
        y2 = y;
      }
      clear = true;
      for(let j = x1; j &lt;= x2; j++) {
        for(let k = y1; k &lt;= y2; k++) {
          if(!this.floor.map.isOnMap(j, k)) {
            clear = false;
            break;
          }
          if(!clear)
            break;
        }
      }
      if(clear)
        totalCorners++;
    }
    if(totalCorners === 0)
      return false;
    if(totalCorners &lt; 4)
      this.maneuver = true;
    return true;
  }

  /**
   * Finds distance between monster and coodinate.
   * @param x 
   * @param y 
   * @return {double}
   */
  findDistance(x, y) {
    let asquared = Math.pow(x - this.x, 2);
    let bsquared = Math.pow(y - this.y, 2);
    let c = Math.sqrt(asquared + bsquared);
    return c;
  }

  /** ~WIP, UNFINISHED (need PC implementation)
   * Finds closest PC that can be seen and targets it.
   */
  canSeePC() {
    // this.targetAquired = false;
    // let indexArray = [];
    // for i = 0 to map.numPcs/map.PCarray.length
    // __if(canSee(PC[i].x, PC[i].y));, repeat for all (most) pixels of pc
    // ____push i onto indexArray;
    // find closest PC that can be seen: use this.findDistance(pcx, pcy) and find minimum to find closest pc of PCs of indexArray
    // assign targetx and targety to closest pc that can be seen
  }

  /** 
   * ~WIP, UNFINISHED (need to check for collisions for items/players)
   * 
   * Monster moves to an adjacent, unoccupied location.
   */
  wander() {
    let random = Math.floor(Math.random() * 4); 
    let prevX = this.x;
    let prevY = this.y;
    if(random === 0)
      this.x += MonsterCommon.SPRITE_SIZE;
    else if(random === 1)
      this.x -= MonsterCommon.SPRITE_SIZE;
    else if(random === 2)
      this.y += MonsterCommon.SPRITE_SIZE;
    else if(random === 3)
      this.y -= MonsterCommon.SPRITE_SIZE;
    if(!this.spriteIsOnMap()) {
      this.x = prevX;
      this.y = prevY;
      // this.wander(); Stack overflow causes clients to disconnect
    }
    this.targetx = this.x;
    this.x = prevX;
    this.targety = this.y;
    this.y = prevY;
  }

  /**
   * Sets the position closer to the target position.
   */
  move() {
    if(this.targetx &lt; this.x)
      this.x--;
    else this.x++;
    if(this.targety &lt; this.y)
      this.y--;
    else this.y++;
    if(this.spriteCollision())
      this.wander();
  }

  /**
   * ~WIP, UNFINISHED (needs to be able to move strategically based on PC last seen location
   * 
   * Moves monster.
   * If PC has been seen, move strategically towards last seen location.
   * Else (if PC not seen yet or last seen PC location has been explored) the monster wanders.
   */
  figureOutWhereToGo() {
    //this.canSeePC();
    if(!this.targetAquired) {
      this.wander();
    } else {
      //move strategically, to be implemented later when PC is on map WIP
      console.log("omw bro");
    }
  }

  /**
   * ~WIP, UNFINISHED (merge logic with PC class once implemented)
   * 
   * Monster attacks PC
   * @param {*} PCid id for player that monster is attacking
   */
  attack(PCid) {
    //(decrement pc health and check for pc death) within PC's beAttacked method
    // below: psuedo until PC is implemented
    this.floor.map.PC[PCid].beAttacked(this.damage);
  }

  /**
   * ~WIP, UNFINISHED (merge logic with PC class once implemented)
   * 
   * PC attacks Monster
   * @param {*} hp health points that the monster's health decrements by
   */
  beAttacked(hp) {
    this.hp -= hp;
    if(this.hp &lt;= 0)
      this.die();
  }

  /** todo test
   * ~WIP drop items down the road
   * 
   * Monster dies.
   */
  die() {
    this.floor.monsters.splice(this.id, 1);
    console.log("DEATH: " + this.floor.monsters.length);
    //delete from DB
    // drop item in the future
  }

  /** 
   * Places monster in a random "room" with no other monsters.
   */
  placeInRandomRoom() {
    let numRooms = this.floor.map.rooms.length;
    this.initialRoom = Math.floor(Math.random() * numRooms);
    for(let i = 0; i &lt; this.floor.monsters.length; i++) {
      if(this.id !== i &amp;&amp; this.floor.monsters[i].initialRoom === this.initialRoom) {
        this.placeInRandomRoom();
      }
    }
    let randomDiffX = Math.floor(Math.random() * this.floor.map.rooms[this.initialRoom].width); 
    this.x = this.floor.map.rooms[this.initialRoom].x + randomDiffX;
    let randomDiffY = Math.floor(Math.random() * this.floor.map.rooms[this.initialRoom].height); 
    this.y = this.floor.map.rooms[this.initialRoom].y + randomDiffY;
    if(!this.spriteIsOnMap())
      this.placeInRandomRoom();
  }

  /**
   * Check to see if whole sprite is on the map.
   * @returns {boolean}
   */
  spriteIsOnMap() {
    return this.floor.map.isOnMap(this.x, this.y) &amp;&amp; this.floor.map.isOnMap(this.x + MonsterCommon.SPRITE_SIZE, this.y) 
    &amp;&amp; this.floor.map.isOnMap(this.x, this.y + MonsterCommon.SPRITE_SIZE) &amp;&amp; this.floor.map.isOnMap(this.x + MonsterCommon.SPRITE_SIZE, this.y + MonsterCommon.SPRITE_SIZE);
  }

  /**
   * Checks to see if there's a monster colliding with this monster. todo untested
   * Compares corners of each sprite to do so.
   * @returns {boolean}
   */
  spriteCollision() {
    for(let i = 0; i &lt; this.floor.monsters.length; i++) {
      if(this.id !== i) {
        if(this.floor.monsters[i].x >= this.x &amp;&amp; this.floor.monsters[i].x &lt;= this.x + MonsterCommon.SPRITE_SIZE) { // within x bounds
          if(this.floor.monsters[i].y >= this.y &amp;&amp; this.floor.monsters[i].y &lt;= this.y + MonsterCommon.SPRITE_SIZE) { // and within y bounds
            return true;
          }
        }
      }
    }
    return false;
  }

  /**
   * Manually set coordinates for a single
   */
  setCoodinates(x, y) {
    this.x = x;
    this.y = y;
  }

  // changes for an actual test case: todo
  // remove any monsters in room one
  // place monster in room one
  // manually placing pc
  // replace this.x with this.floor.monsters[0].x
  // outputs: all true
  // pursue_test() {
  //   // TEST 1: directly left/right/up/down
  //   let pcx = this.x;
  //   let pcy = this.y;
  //   let cantplacepc = false;
    
  //   pcx += 1.5 * SPRITE_SIZE; // right
  //   if(!this.floor.map.isOnMap(pcx, pcy)) { 
  //     pcx -= 2 * SPRITE_SIZE; // left
  //     if(!this.floor.map.isOnMap(pcx, pcy)) { 
  //       pcx = this.x;
  //       pcy += 1.5 * SPRITE_SIZE; // down
  //       if(!this.floor.map.isOnMap(pcx, pcy)) { 
  //         pcy -= 2 * SPRITE_SIZE; // up
  //         if(!this.floor.map.isOnMap(pcx, pcy)) { 
  //           cantplacepc = true;
  //         }
  //       }
  //     }
  //   }

  //   let test1 = false;
  //   if(!cantplacepc) {
  //     test1 = this.canSee(pcx, pcy);
  //     console.log("test1: " + test1);
  //   } else {
  //     console.log("Could not place pc for test1."); // should not occur
  //   }

  //   // TEST 2: diagonal 
  //   pcx = this.x;
  //   pcy = this.y;
  //   cantplacepc = false;
    
  //   pcx += 1.5 * SPRITE_SIZE; // lower right
  //   pcy += 1.5 * SPRITE_SIZE;
  //   if(!this.floor.map.isOnMap(pcx, pcy)) { 
  //     pcx -= 2 * SPRITE_SIZE; // lower left
  //     if(!this.floor.map.isOnMap(pcx, pcy)) { 
  //       pcy -= 2 * SPRITE_SIZE; // upper left
  //       if(!this.floor.map.isOnMap(pcx, pcy)) { 
  //         pcx += 2 * SPRITE_SIZE; // upper right
  //         if(!this.floor.map.isOnMap(pcx, pcy)) { 
  //           cantplacepc = true;
  //         }
  //       }
  //     }
  //   }

  //   let test2 = false;
  //   if(!cantplacepc) {
  //     test2 = this.canSee(pcx, pcy);
  //     console.log("test2: " + test2);
  //     if(!test2)
  //       console.log(pcx, pcy, "monster:", this.x, this.y);
  //   } else {
  //     console.log("Could not place pc for test2. Run test on new map, as room 0 was generated as a corridor.");
  //   }

  //   // TEST 3: pc off map
  //   pcx = 0;
  //   pcy = 0;

  //   let test3 = false;
  //   test3 = !this.canSee(pcx, pcy);
  //   console.log("test3: " + test3);

  //   // TEST 4: place in far away room
  //   pcx = 0;
  //   pcy = 0;

  //   let pcRoom = this.floor.map.rooms.length - 1; // a room far away from the testing monster
  //   let randomDiffX = Math.floor(Math.random() * this.floor.map.rooms[pcRoom].width); 
  //   pcx = this.floor.map.rooms[pcRoom].x + randomDiffX;
  //   let randomDiffY = Math.floor(Math.random() * this.floor.map.rooms[pcRoom].height); 
  //   pcy = this.floor.map.rooms[pcRoom].y + randomDiffY;

  //   let test4 = false;
  //   test4 = !this.canSee(pcx, pcy);
  //   console.log("test4: " + test4);
  // } 
}

MonsterCommon.SPRITE_SIZE = 48;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-backend_game_Floor.html">backend/game/Floor</a></li><li><a href="module-backend_game_GameMap.html">backend/game/GameMap</a></li><li><a href="module-browser_Floor.html">browser/Floor</a></li><li><a href="module-browser_GameMap.html">browser/GameMap</a></li><li><a href="module-common_Floor.html">common/Floor</a></li><li><a href="module-common_game-map_Corridor.html">common/game-map/Corridor</a></li><li><a href="module-common_game-map_GameMap.html">common/game-map/GameMap</a></li><li><a href="module-common_game-map_Room.html">common/game-map/Room</a></li><li><a href="module-FpsCounter.html">FpsCounter</a></li><li><a href="module-Monster.html">Monster</a></li></ul><h3>Classes</h3><ul><li><a href="Clock.html">Clock</a></li><li><a href="Env.html">Env</a></li><li><a href="jsApiReporter.html">jsApiReporter</a></li><li><a href="module-common_Floor-Floor.html">Floor</a></li><li><a href="module-common_game-map_Corridor.html">common/game-map/Corridor</a></li><li><a href="module-common_game-map_GameMap.html">common/game-map/GameMap</a></li><li><a href="module-common_game-map_Room.html">common/game-map/Room</a></li><li><a href="module-FpsCounter.html">FpsCounter</a></li><li><a href="Spy.html">Spy</a></li></ul><h3>Namespaces</h3><ul><li><a href="async-matchers.html">async-matchers</a></li><li><a href="jasmine.html">jasmine</a></li><li><a href="matchers.html">matchers</a></li><li><a href="Spy_calls.html">calls</a></li></ul><h3>Interfaces</h3><ul><li><a href="Reporter.html">Reporter</a></li><li><a href="SpyStrategy.html">SpyStrategy</a></li></ul><h3>Global</h3><ul><li><a href="global.html#afterAll">afterAll</a></li><li><a href="global.html#afterEach">afterEach</a></li><li><a href="global.html#beforeAll">beforeAll</a></li><li><a href="global.html#beforeEach">beforeEach</a></li><li><a href="global.html#callbackify">callbackify</a></li><li><a href="global.html#describe">describe</a></li><li><a href="global.html#destroy">destroy</a></li><li><a href="global.html#expect">expect</a></li><li><a href="global.html#expectAsync">expectAsync</a></li><li><a href="global.html#fail">fail</a></li><li><a href="global.html#fdescribe">fdescribe</a></li><li><a href="global.html#fit">fit</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#isAuthenticated">isAuthenticated</a></li><li><a href="global.html#it">it</a></li><li><a href="global.html#pending">pending</a></li><li><a href="global.html#ping">ping</a></li><li><a href="global.html#set">set</a></li><li><a href="global.html#spyOn">spyOn</a></li><li><a href="global.html#spyOnProperty">spyOnProperty</a></li><li><a href="global.html#xdescribe">xdescribe</a></li><li><a href="global.html#xit">xit</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Oct 30 2018 14:31:47 GMT-0500 (Central Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
