<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: shared/game-map.mjs</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: shared/game-map.mjs</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* eslint-disable complexity,no-extra-parens,no-mixed-operators */
/** @module GameMap */

const BLOCK_SIZE = 48;
const BLOCK_TYPE = "0-1-box-big";
const SIZE = 10;
const NODES = SIZE ** 2;
const MIN_ROOM = 4;
const MAX_ROOM = 10;
const MAX_Y_DIST = 3;
const ROOM_CHANCE = 0.2;
const MAX_SCREEN_WIDTH = SIZE * (MAX_ROOM + MAX_Y_DIST);

// The map file header
const HEADER = [
  0x4d, 0x4c, // magic
  1, // version
  0 // padding
];

/**
 * Map a 2d coordinate to a 1d coordinate
 * @private
 * @param {*} x 
 * @param {*} y 
 */
const d21 = (x, y, size = SIZE) => {
  return y * size + x;
};

/**
 * Map a 1d coordinate to a 2d coordinate
 * @private
 * @param {*} x 
 * @param {*} y 
 */
const d12 = (i, size = SIZE) => {
  return [i % size, Math.floor(i / size)];
};

/**
 * Make sure the map parent has a Map in it for the value key
 * @private
 * @param parent 
 * @param key 
 */
const ensureMap = (parent, key) => {
  if(!parent.has(key)) {
    parent.set(key, new Map());
  }
};

/**
 * A room in the maze
 * @typedef {object} Room
 * @prop {number} x X coordinate of the room
 * @prop {number} y Y coordinate of the room
 * @prop {number} width Width coordinate of the room
 * @prop {number} height Height coordinate of the room
 */

/**
 * An edge in the maze graph
 * @typedef {object} Edge
 * @prop {number} x The x coordinate for the corridor to start
 * @prop {number} y The y coordinate for the corridor to start
 * @prop {number} xDir If the edge weight is in the x direction
 * @prop {number} weight The length or width of the edge
 */

/**
 * A map for a game
 * @prop {Room[]} rooms The rooms in the dungeon
 * @prop {Map&lt;Map&lt;Edge>>} edges The edges/corridors in the map (Map { roomIdx => Map { roomIdx => Edge } })
 * 
 * @prop {number} BLOCK_SIZE Number of pixels of one square on the map
 */
export default class GameMap {
  constructor() {
    this.map = [];
  }

  /**
   * Geneate a game map
   * @returns {GameMap}
   */
  static generate() {
    let map = new GameMap();
    
    Object.assign(map, generateMap(generateMaze()));

    map._buildMap();

    return map;
  }

  /**
   * Get a subset of the map inside rectangle specified by the coordiates
   * @param {number} xMin x coordinate for the top left corner
   * @param {number} yMin y coordinate for the top left corner
   * @param {number} xMax x coordinate for the bottom right corner
   * @param {number} yMax y coordinate for the bottom right corner
   */
  getMapFor(xMin, yMin, xMax, yMax) {
    let out = [];

    for(let y = Math.floor(yMin / BLOCK_SIZE); y &lt; Math.ceil(yMax / BLOCK_SIZE) &amp;&amp; y &lt; MAX_SCREEN_WIDTH; ++y) {
      for(let x = Math.floor(xMin / BLOCK_SIZE); x &lt; Math.ceil(xMax / BLOCK_SIZE) &amp;&amp; x &lt; MAX_SCREEN_WIDTH; ++x) {
        out.push({
          x: x * BLOCK_SIZE,
          y: y * BLOCK_SIZE,
          width: BLOCK_SIZE,
          height: BLOCK_SIZE,
          type: this.map[d21(x, y, MAX_SCREEN_WIDTH)]
        });
      }
    }

    return out;
  }

  /**
   * Check if a point is on the map/floor
   * @param {number} x
   * @param {number} y
   * @returns {boolean}
   */
  isOnMap(x, y) {
    let _x = Math.round(x / BLOCK_SIZE);
    let _y = Math.round(y / BLOCK_SIZE);

    return !!this.map[d21(_x, _y)];
  }

  /**
   * Generate the tile matrix based on the graph
   * @private
   */
  _buildMap() {
    this.map = [];

    for(let i = 0; i &lt; this.rooms.length; ++i) {
      let box = this.rooms[i];

      // render the box
      for(let by = box.y; by &lt; box.y + box.height; ++by) {
        for(let bx = box.x; bx &lt; box.x + box.width; ++bx) {
          this.map[d21(bx, by, MAX_SCREEN_WIDTH)] = BLOCK_TYPE;
        }
      }

      // render the corridor to the box to the left
      if(i % SIZE > 0 &amp;&amp; this.edges.get(i).has(i - 1)) {
        let edge = this.edges.get(i).get(i - 1);

        for(let bx = edge.x; bx &lt;= edge.x + edge.weight; ++bx) {
          this.map[d21(bx, edge.y, MAX_SCREEN_WIDTH)] = BLOCK_TYPE;
          this.map[d21(bx, edge.y + 1, MAX_SCREEN_WIDTH)] = BLOCK_TYPE;
        }
      }
      
      // render the corridor to the box above
      if(i >= SIZE &amp;&amp; this.edges.get(i).has(i - SIZE)) {
        let edge = this.edges.get(i).get(i - SIZE);

        for(let by = edge.y; by &lt;= edge.y + edge.weight; ++by) {
          this.map[d21(edge.x, by, MAX_SCREEN_WIDTH)] = BLOCK_TYPE;
          this.map[d21(edge.x + 1, by, MAX_SCREEN_WIDTH)] = BLOCK_TYPE;
        }
      }
    }
  }

  /**
   * &lt;pre>
   * Serialize the game map
   * 
   * Game map format 
   * NAME    | size (in bytes)
   * magic   | 2
   * version | 1
   * --- 1 byte padding ---
   * num edges | 2 (16-bit little endian)
   * --- edges 5 bytes each ---
   * --- rooms 3 bytes each ---
   * 
   * NOTE: There are always NODES nodes in a map
   * 
   * Edge format
   * NAME         | size (in bytes)
   * from node id | 1
   * to node id   | 1
   * x            | 1
   * y            | 1
   * xDir         | 1/8 (shares this byte with weight)
   * weight       | 7/8 (offset 1 bit)
   * 
   * Room format
   * NAME       | size (in bytes)
   * x          | 1
   * y          | 1
   * width - 2  | 1/2 (shares this byte with height)
   * height - 2 | 1/2 (offset 4 bits)
   * &lt;/pre>
   * 
   * @returns {ArrayBuffer} The serialized map
   */
  serialize() {
    /* eslint-disable arrow-parens,arrow-body-style */
    let numEdges = Array.from(this.edges.values())
      .map(edge => edge.size)
      .reduce((a, b) => a + b, 0);
    /* eslint-enable arrow-parens,arrow-body-style */

    let bufferLength = HEADER.length + 2 + (numEdges / 2 * 5) + (NODES * 3);
    let buffer = new ArrayBuffer(bufferLength);
    let u8 = new Uint8Array(buffer);
    let u16 = new Uint16Array(buffer, HEADER.length, HEADER.length + 2);

    HEADER.forEach((value, i) => {
      u8[i] = value;
    });

    u16[0] = numEdges / 2;

    let offset = HEADER.length + 2;

    for(let [fromNode, subEdges] of this.edges) {
      for(let toNode of [fromNode - 1, fromNode - SIZE]) {
        let edge = subEdges.get(toNode);

        if(!edge) {
          continue;
        }

        if(edge.x > 255 || edge.y > 255) {
          throw new Error("Edge x or y values exceded treshhold");
        }

        if(edge.weight > 127) {
          throw new Error("Edge weight value exceded threshold");
        }

        if(typeof edge.xDir !== "boolean") {
          throw new Error("Expected edge.xDir to be a boolean");
        }

        u8[offset++] = fromNode;
        u8[offset++] = toNode;
        u8[offset++] = edge.x;
        u8[offset++] = edge.y;
        u8[offset++] = (edge.weight &lt;&lt; 1) | (+edge.xDir); // eslint-disable-line no-bitwise
      }
    }

    for(let room of this.rooms) {
      if(room.x > 255 || room.y > 255) {
        throw new Error("Room x or y values exceded treshhold");
      }

      if(room.width > 17 || room.height > 17) {
        throw new Error("Room width or height values exceded threshold");
      }

      u8[offset++] = room.x;
      u8[offset++] = room.y;
      u8[offset++] = (room.width - 2) | ((room.height - 2) &lt;&lt; 4); // eslint-disable-line no-bitwise
    }

    if(offset !== buffer.byteLength) {
      throw new Error(`Offset does not match buffer ${offset} != ${buffer.byteLength}`);
    }

    return buffer;
  }

  /**
   * Parse a previously serialized map
   * @param {ArrayBuffer} buffer The serialized map
   * @returns {GameMap}
   */
  static parse(buffer) {
    let u8 = new Uint8Array(buffer);

    if(u8[0] !== HEADER[0] || u8[1] !== HEADER[1]) {
      throw new Error("File is not a map");
    }

    switch(u8[2]) {
    case 1:
      return v1Parse(buffer);
    
    default:
      throw new Error(`Unsupported version ${u8[2]}`);
    }
  }
}

/**
 * Map parser for version 1
 * @private
 * @param buffer The raw map
 * @returns {GameMap}
 */
function v1Parse(buffer) {
  let map = new GameMap();
  map.edges = new Map();
  map.rooms = [];

  let u8 = new Uint8Array(buffer);
  let u16 = new Uint16Array(buffer, HEADER.length, HEADER.length + 2);
  let offset = HEADER.length + 2;

  let numEdges = u16[0];

  for(let i = 0; i &lt; numEdges; ++i) {
    let fromNode = u8[offset++];
    let toNode = u8[offset++];

    let edge = {
      x: u8[offset++],
      y: u8[offset++]
    };

    let wd = u8[offset++];
    edge.xDir = !!(wd &amp; 1); // eslint-disable-line no-bitwise
    edge.weight = (wd >> 1) &amp; 127; // eslint-disable-line no-bitwise

    ensureMap(map.edges, fromNode);
    ensureMap(map.edges, toNode);

    map.edges.get(fromNode).set(toNode, edge);
    map.edges.get(toNode).set(fromNode, edge);
  }

  for(let i = 0; i &lt; NODES; ++i) {
    let room = {
      x: u8[offset++],
      y: u8[offset++]
    };

    let wh = u8[offset++];
    room.width = (wh &amp; 15) + 2; // eslint-disable-line no-bitwise
    room.height = ((wh >> 4) &amp; 15) + 2; // eslint-disable-line no-bitwise

    map.rooms.push(room);
  }

  map._buildMap();

  return map;
}

/**
 * The basic maze generation algorithm.
 * @private
 * @returns A map of edges
 */
const generateMaze = () => {
  let unvisited = new Set();
  let corridors = new Map();
  let stack = [];

  for(let i = 0; i &lt; NODES; ++i) {
    unvisited.add(i);
  }

  let startingPoint = Math.floor(Math.random() * unvisited.size);
  stack.push(startingPoint);

  while(stack.length) {
    let current = stack[stack.length - 1];
    let [x, y] = d12(current);
    
    // find all unvisited neighbours
    let unvisitedNeighbours = [];

    if(unvisited.has(d21(x + 1, y)) &amp;&amp; x + 1 &lt; SIZE) {
      unvisitedNeighbours.push(d21(x + 1, y));
    }

    if(unvisited.has(d21(x, y + 1)) &amp;&amp; y + 1 &lt; SIZE) {
      unvisitedNeighbours.push(d21(x, y + 1));
    }

    if(unvisited.has(d21(x - 1, y)) &amp;&amp; x - 1 >= 0) {
      unvisitedNeighbours.push(d21(x - 1, y));
    }

    if(unvisited.has(d21(x, y - 1)) &amp;&amp; y - 1 >= 0) {
      unvisitedNeighbours.push(d21(x, y - 1));
    }

    // all of our neighbours have been visited go back to the previous node
    if(!unvisitedNeighbours.length) {
      stack.pop();
      continue;
    }

    // visit a neighbouring cell
    let toCell = unvisitedNeighbours[Math.floor(Math.random() * unvisitedNeighbours.length)];
    unvisited.delete(toCell);

    // create the edges for the corridors
    if(!corridors.has(toCell)) {
      corridors.set(toCell, new Set());
    }

    if(!corridors.has(current)) {
      corridors.set(current, new Set());
    }

    corridors.get(toCell).add(current);
    corridors.get(current).add(toCell);

    stack.push(toCell);
  }

  return corridors;
};

/**
 * Expand the maze generated by generateMaze into something with differently sized rooms
 * @private
 * @param {*} corridors 
 * @returns {Object} {edges, boxes}
 */
const generateMap = (corridors) => {
  // Coords for the room we are placing
  let x = 1;
  let y = 1;
  // Height of the tallest room in this row
  let maxHeight = 0;
  // Location width and heights of all rooms
  let rooms = [];
  // More detailed edge representations
  let edges = new Map();

  // Place rooms onto the map
  for(let i = 0; i &lt; NODES; ++i) {
    // We are at the end of this row tart a new row
    if(i % SIZE === 0 &amp;&amp; i > 0) {
      x = 1;
      y += maxHeight + Math.floor(Math.random() * (MAX_Y_DIST - 1)) + 1;
      maxHeight = 0;
    }

    let width = 2;
    let height = 2;

    // determine if this box should be a room
    if(Math.random() &lt; ROOM_CHANCE || corridors.get(i).size === 1) {
      width = Math.floor(Math.random() * (MAX_ROOM - MIN_ROOM)) + MIN_ROOM;
      height = Math.floor(Math.random() * (MAX_ROOM - MIN_ROOM)) + MIN_ROOM;
    }

    x += Math.max(MAX_ROOM - width, 0);

    // save for corridor rendering
    rooms.push({x, y, width, height});

    maxHeight = Math.max(height, maxHeight);

    // Render a corridor to the box to our left (if there is one)
    if(i % SIZE > 0 &amp;&amp; corridors.get(i).has(i - 1)) {
      let box = rooms[i - 1];

      // find a row that we have in common
      let sharedHeight = Math.min(box.height, height) - 1;
      let yOffset = Math.floor(Math.random() * sharedHeight);

      // Add weights to the graph
      let edge = {
        weight: x - (box.x + box.width),
        xDir: true,
        x: box.x + box.width,
        y: y + yOffset
      };

      ensureMap(edges, i);
      ensureMap(edges, i - 1);

      edges.get(i).set(i - 1, edge);
      edges.get(i - 1).set(i, edge);
    }

    // Render a corridor to the box above us
    if(y > 0 &amp;&amp; corridors.get(i).has(i - SIZE)) {
      let box = rooms[i - SIZE];

      // find a column that we have in common
      let xStart = Math.max(x, box.x);
      let sharedWidth = Math.min(width - (x - xStart), box.width - (box.x - xStart)) - 1;
      let xPos = Math.floor(Math.random() * sharedWidth) + xStart;

      // Add weights to the graph
      let edge = {
        weight: y - (box.y + box.height),
        xDir: false,
        x: xPos,
        y: box.y + box.height
      };

      ensureMap(edges, i);
      ensureMap(edges, i - SIZE);

      edges.get(i).set(i - SIZE, edge);
      edges.get(i - SIZE).set(i, edge);
    }

    x += width + 1;
  }

  return {edges, rooms};
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-FpsCounter.html">FpsCounter</a></li><li><a href="module-GameMap.html">GameMap</a></li></ul><h3>Classes</h3><ul><li><a href="module-FpsCounter.html">FpsCounter</a></li><li><a href="module-GameMap.html">GameMap</a></li></ul><h3>Global</h3><ul><li><a href="global.html#callbackify">callbackify</a></li><li><a href="global.html#destroy">destroy</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#isAuthenticated">isAuthenticated</a></li><li><a href="global.html#set">set</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Oct 09 2018 21:35:06 GMT-0500 (Central Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
